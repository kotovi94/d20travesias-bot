require('dotenv').config();
const { Client, GatewayIntentBits } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus } = require('@discordjs/voice');
const { spawn } = require('child_process');
const axios = require('axios');

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
    ]
});

const prefix = "!";
const queue = new Map(); // üéµ Cola de reproducci√≥n global

client.once('ready', () => {
    console.log(`üé≠ El bardo est√° listo para tocar su la√∫d en tierras de ${client.user.tag}!`);
});

// üîÑ Funci√≥n para elegir una respuesta aleatoria de un array
function getRandomResponse(responses) {
    return responses[Math.floor(Math.random() * responses.length)];
}

client.on('messageCreate', async message => {
    if (!message.content.startsWith(prefix) || message.author.bot) return;
    if (message.channel.id !== '1295876800408322130') return; // Solo responde en este canal

    const args = message.content.slice(prefix.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();
    const guildId = message.guild.id;
    const voiceChannel = message.member.voice.channel;
    let serverQueue = queue.get(guildId);

    // üé§ Conectar al canal de voz
    if (command === 'join') {
        if (!voiceChannel) return message.reply('‚ö†Ô∏è ¬°Oh, viajero! Para escuchar mis melod√≠as, debes estar en un sal√≥n de canto (canal de voz).');

        if (!serverQueue) {
            serverQueue = {
                songs: [],
                connection: joinVoiceChannel({
                    channelId: voiceChannel.id,
                    guildId: guildId,
                    adapterCreator: message.guild.voiceAdapterCreator
                }),
                player: createAudioPlayer()
            };
            queue.set(guildId, serverQueue);
            serverQueue.connection.subscribe(serverQueue.player);
        }

        const joinResponses = [
            "üéª ¬°Que resuenen las cuerdas y el esp√≠ritu se eleve! ¬°Estoy listo para tocar!",
            "üìØ ¬°El bardo ha llegado! Preparad vuestros o√≠dos para canciones √©picas.",
            "üé∂ Entra el trovador, listo para llenar este lugar de armon√≠as m√°gicas."
        ];

        message.reply(getRandomResponse(joinResponses));
    }

    // üéµ Reproducir una canci√≥n
    if (command === 'play') {
        if (!serverQueue || !serverQueue.connection) return message.reply("üé≠ ¬°Oh, noble alma! Primero deb√©is invitarme con `!join`.");
        if (!args[0]) return message.reply("üìú ¬°Un bardo necesita su partitura! Proporci√≥name un enlace de YouTube.");

        const url = args[0].split("&")[0];
        serverQueue.songs.push(url);

        if (serverQueue.player.state.status !== AudioPlayerStatus.Playing) {
            playSong(guildId);
        }

        const playResponses = [
            `üéº ¬°Ah, esta melod√≠a promete ser legendaria!`,
            `üé∂ ¬°Una nueva canci√≥n para los anales de la historia!`,
            `üéª ¬°Que comience el concierto! La m√∫sica nos guiar√°.`
        ];

        message.reply(getRandomResponse(playResponses));
    }

    // üé∂ Controles para `!play`
    if (command === 'stop') {
        if (!serverQueue) return message.reply("üé≠ ¬°No hay nada que detener! No he comenzado a tocar a√∫n.");
        
        serverQueue.songs = [];
        serverQueue.player.stop();

        const stopResponses = [
            "üõë ¬°El silencio cae como un tel√≥n en esta taberna!",
            "üé≠ ¬°La canci√≥n ha terminado, pero la historia contin√∫a!",
            "üéª Deteniendo la m√∫sica... hasta que alguien pida otra ronda."
        ];

        message.reply(getRandomResponse(stopResponses));
    }

    if (command === 'pause') {
        if (!serverQueue || !serverQueue.player) return message.reply("‚ö†Ô∏è ¬°No hay melod√≠a en el aire para pausar, viajero!");
        serverQueue.player.pause();

        const pauseResponses = [
            "‚è∏Ô∏è ¬°Ah, un momento de respiro! Pero la m√∫sica volver√°.",
            "üéº ¬°El trovador se toma un descanso, mas la historia no ha acabado!",
            "üìú ¬°La sinfon√≠a espera! Pausando esta pieza con gracia."
        ];

        message.reply(getRandomResponse(pauseResponses));
    }

    if (command === 'resume') {
        if (!serverQueue || !serverQueue.player) return message.reply("üìú ¬°No hay canci√≥n en espera para continuar, noble caballero!");
        serverQueue.player.unpause();

        const resumeResponses = [
            "‚ñ∂Ô∏è ¬°La m√∫sica regresa, como un h√©roe de leyenda!",
            "üé∂ ¬°El la√∫d vuelve a sonar! Preparaos para la siguiente estrofa.",
            "üéª ¬°Que la melod√≠a siga! No hay descanso para un bardo."
        ];

        message.reply(getRandomResponse(resumeResponses));
    }

    if (command === 'skip') {
        if (!serverQueue || !serverQueue.player) return message.reply("‚è≠Ô∏è ¬°No hay canci√≥n que saltar, viajero impaciente!");
        serverQueue.player.stop();

        const skipResponses = [
            "‚è≠Ô∏è ¬°Adelante con la pr√≥xima balada! Este cuento debe continuar.",
            "üé≠ ¬°Saltamos esta historia para llegar a un nuevo acto!",
            "üéº ¬°Siguiente canci√≥n! Que el fest√≠n de sonidos no termine."
        ];

        message.reply(getRandomResponse(skipResponses));
    }

    // üö™ Desconectar el bot manualmente del canal de voz
    if (command === 'leave') {
        if (!serverQueue || !serverQueue.connection) return message.reply("‚ö†Ô∏è No puedo salir de donde nunca estuve, noble guerrero.");
        
        serverQueue.connection.destroy();
        queue.delete(guildId);

        const leaveResponses = [
            "üëã ¬°El bardo se retira, pero volver√° cuando la historia lo requiera!",
            "üé≠ ¬°Mi acto ha terminado! Que las melod√≠as os acompa√±en hasta la pr√≥xima.",
            "üìØ ¬°El trovador parte en busca de nuevas canciones y viejas leyendas!"
        ];

        message.reply(getRandomResponse(leaveResponses));
    }
});

// üîÑ Reproducir una canci√≥n (M√∫sica en cola)
async function playSong(guildId) {
    const serverQueue = queue.get(guildId);
    if (!serverQueue || serverQueue.songs.length === 0) return;

    const songUrl = serverQueue.songs[0];

    try {
        const process = spawn('yt-dlp', ['-f', 'bestaudio', '--no-playlist', '-o', '-', songUrl], { stdio: ['ignore', 'pipe', 'ignore'] });
        const resource = createAudioResource(process.stdout);
        serverQueue.player.play(resource);
        serverQueue.connection.subscribe(serverQueue.player);

        serverQueue.player.on(AudioPlayerStatus.Idle, () => {
            process.kill();
            playSong(guildId);
        });

    } catch (error) {
        console.error(`‚ùå Error al reproducir: ${error.message}`);
    }
}
// ID de los canales
const INPUT_CHANNEL_ID = "1348784767629262921"; // üì• Canal donde el DM escribe `!quest`
const OUTPUT_CHANNEL_ID = "1181356950211022988"; // üìú Canal donde el bot publica la misi√≥n

// üîÑ Funci√≥n para elegir un elemento aleatorio de una lista
function getRandomElement(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

// üìú Elementos narrativos para generar misiones
const hooks = [
    "Un viajero herido llega a la taberna y os susurra una √∫ltima petici√≥n...",
    "El rey ha enviado un mensajero en busca de valientes dispuestos a enfrentar un gran peligro...",
    "Un anciano os entrega un mapa cubierto de polvo y os dice: 'Solo vosotros pod√©is lograrlo...'",
    "La luna roja brilla sobre el castillo maldito, se√±al de que algo oscuro est√° por ocurrir...",
    "Un gremio de mercenarios busca aventureros para una misi√≥n de alto riesgo...",
];

const locations = [
    "las ruinas antiguas de Eldoria, donde la magia a√∫n susurra en el viento",
    "la fortaleza maldita en las Monta√±as Sombr√≠as, donde nadie ha regresado con vida",
    "el bosque encantado de Lirion, donde los √°rboles susurran secretos a los que se atreven a escuchar",
    "la ciudad prohibida de Karaz'dun, donde la alquimia prohibida ha tomado vida propia",
    "las catacumbas bajo la Catedral de la Llama Eterna, hogar de esp√≠ritus inquietos",
];

const dangers = [
    "una tormenta m√°gica impide el paso y los vientos cantan nombres olvidados",
    "las sombras parecen moverse por s√≠ solas, susurrando palabras incomprensibles",
    "una horda de criaturas de pesadilla ha sido avistada en los alrededores",
    "los viajeros que se aventuran cerca desaparecen sin dejar rastro",
    "antiguas trampas a√∫n protegen los secretos ocultos en el lugar",
];

const objectives = [
    "recuperar un artefacto legendario antes de que caiga en malas manos",
    "destruir un portal demon√≠aco que amenaza con desatar el caos",
    "rescatar a un noble desaparecido y descubrir qu√© le ha ocurrido",
    "asesinar a un traidor que planea vender los secretos del reino",
    "descifrar un enigma arcano que ha confundido a generaciones de sabios",
];

const enemies = [
    "un ej√©rcito de no-muertos liderados por un antiguo se√±or de la guerra",
    "un mago oscuro que busca la inmortalidad a cualquier precio",
    "una bestia legendaria que ha despertado despu√©s de mil a√±os de letargo",
    "una secta de adoradores de un dios prohibido, dispuestos a todo por su causa",
    "un ladr√≥n de almas que se oculta en las sombras y nunca deja sobrevivientes",
];

const resolutions = [
    "Si la misi√≥n tiene √©xito, una nueva era de prosperidad comenzar√°.",
    "El fracaso significar√° la destrucci√≥n de un reino entero.",
    "El destino del mundo pende de un hilo, y solo vosotros pod√©is inclinar la balanza.",
    "Las antiguas profec√≠as mencionaban este d√≠a... ¬øser√©is los h√©roes de la leyenda?",
    "Nada volver√° a ser igual despu√©s de esta aventura.",
];

const rewards = [
    "un cofre lleno de oro, gemas y reliquias olvidadas",
    "una audiencia con el rey y un t√≠tulo nobiliario",
    "una antigua espada encantada que solo responde a los dignos",
    "el conocimiento secreto de los sabios de la Torre Arcana",
    "una tierra propia en la frontera, con la promesa de gloria y riqueza",
];

client.once('ready', () => {
    console.log(`üõ°Ô∏è El bardo est√° listo para narrar aventuras en ${client.user.tag}!`);
});

client.on('messageCreate', async message => {
    // Ignorar mensajes de bots y verificar el canal de entrada
    if (message.author.bot || message.channel.id !== INPUT_CHANNEL_ID) return;

    const args = message.content.slice(prefix.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();

    if (command === 'quest') {
        const hook = getRandomElement(hooks);
        const location = getRandomElement(locations);
        const danger = getRandomElement(dangers);
        const objective = getRandomElement(objectives);
        const enemy = getRandomElement(enemies);
        const resolution = getRandomElement(resolutions);
        const reward = getRandomElement(rewards);

        const questMessage = `üìú **Nueva Misi√≥n**  
        üé≠ *${hook}*  
        üè∞ Lugar: ${location}  
        ‚ö†Ô∏è Peligro: ${danger}  
        üéØ Objetivo: ${objective}  
        ‚ò†Ô∏è Enemigo Principal: ${enemy}  
        üìñ Resoluci√≥n: ${resolution}  
        üí∞ Recompensa: ${reward}  

        ¬øResponder√©is al llamado de la aventura? ‚öîÔ∏è`;

        const outputChannel = await client.channels.fetch(OUTPUT_CHANNEL_ID);
        if (!outputChannel) {
            console.error("‚ö†Ô∏è No se pudo encontrar el canal de salida.");
            return;
        }

        // Enviar la misi√≥n en el canal de misiones
        await outputChannel.send(questMessage);

        // Confirmaci√≥n para el DM en el canal de entrada
        const confirmationMessages = [
            "üìú ¬°El pergamino ha sido enviado! La misi√≥n ha sido publicada en el tabl√≥n de anuncios.",
            "üé≠ ¬°Los bardos cantar√°n sobre esta nueva misi√≥n! Ahora solo falta que los h√©roes la acepten.",
            "‚öîÔ∏è El destino ha hablado. La misi√≥n ha sido entregada a los aventureros m√°s valientes.",
            "üìñ El libro de leyendas acaba de recibir una nueva historia. La misi√≥n ha sido enviada.",
            "üèπ La flecha ha sido disparada, la misi√≥n ha sido proclamada en el reino."
        ];

        message.reply(getRandomElement(confirmationMessages));
    }
});
client.on('messageCreate', async message => {
    if (!message.content.startsWith(prefix) || message.author.bot) return;

    const args = message.content.slice(prefix.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();

    if (command === 'commands') {
        const helpMessage = `üé≠ **Comandos disponibles:**  
        
üìú **Misiones**  
\`!quest\` - Genera una misi√≥n aleatoria y la publica en el tabl√≥n de anuncios.  

üé∂ **M√∫sica**  
\`!join\` - El bardo se une a tu canal de voz.  
\`!play <URL>\` - A√±ade una canci√≥n a la cola y comienza a tocar.  
\`!pause\` - Pausa la canci√≥n actual.  
\`!resume\` - Reanuda la m√∫sica pausada.  
\`!skip\` - Salta la canci√≥n actual.  
\`!stop\` - Detiene la m√∫sica y vac√≠a la cola.  
\`!leave\` - El bardo se retira del canal de voz.  

*¬°Que las melod√≠as y las historias os gu√≠en en vuestras aventuras!* üé∂‚öîÔ∏è`;

        try {
            // Enviar el mensaje privado al usuario
            await message.author.send(helpMessage);
            // Confirmar en el chat que el mensaje fue enviado por privado
            message.reply("üìú *He enviado un pergamino con la lista de comandos a tus mensajes privados.*");
        } catch (error) {
            console.error("‚ö†Ô∏è No pude enviar un mensaje privado al usuario:", error);
            message.reply("‚ö†Ô∏è *Parece que no puedo enviarte mensajes privados. Revisa tu configuraci√≥n de privacidad.*");
        }
    }
});
client.once('ready', async () => {
    console.log(`üõ°Ô∏è El bardo ${client.user.tag} est√° listo para cantar historias!`);

    const channelId = "1181358348726186015"; // Canal donde se publicar√° el mensaje
    const channel = await client.channels.fetch(channelId);

    if (channel) {
        channel.send(`üìú ¬°Saludos aventureros! Soy **${client.user.username}**, vuestro fiel bardo. üé∂  

Para ver la lista de mis melod√≠as y poderes, usa \`!commands\`. ‚öîÔ∏è`);
    } else {
        console.error("‚ö†Ô∏è No se pudo encontrar el canal de anuncios.");
    }
});

client.on('messageCreate', async message => {
    if (message.author.bot) return;

    // Si el mensaje contiene "comando" o "comandos" (en cualquier parte del texto)
    if (message.content.toLowerCase().includes("comandos") || message.content.toLowerCase().includes("comando")) {
        message.reply(`üìú *Si buscas la lista de comandos, usa \`!commands\`. üé∂* - **${client.user.username}**, el trovador del reino.`);
    }
});


const fs = require('fs');
const path = require('path');


// üéØ CONFIGURACI√ìN
const DISCORD_CHANNEL_ID = "1181358348726186015"; // Canal de Discord donde se publicar√°n los Shorts
const YOUTUBE_CHANNEL_ID = "UCi61VqIS3WlPOhcBbmps7Sg"; // ID del canal "Doble 20"
const YOUTUBE_API_KEY = process.env.YOUTUBE_API_KEY; // Clave de API de YouTube
const CHECK_INTERVAL = 24 * 60 * 60 * 1000; // Revisar cada 24 horas
const TEMP_STORAGE_TIME = 24 * 60 * 60 * 1000; // Tiempo antes de eliminar Shorts (24h)

// üìú Archivo donde se almacenan temporalmente los Shorts publicados
const SHORTS_FILE = path.join(__dirname, 'shorts_temp.json');

// üìú Cargar Shorts ya publicados si existe el archivo
let postedVideos = new Map();
if (fs.existsSync(SHORTS_FILE)) {
    const data = fs.readFileSync(SHORTS_FILE, 'utf8');
    postedVideos = new Map(JSON.parse(data));
}

// üöÄ Funci√≥n para limpiar Shorts que tengan m√°s de 24 horas
function cleanOldShorts() {
    const now = Date.now();
    for (let [videoId, timestamp] of postedVideos.entries()) {
        if (now - timestamp > TEMP_STORAGE_TIME) {
            postedVideos.delete(videoId);
        }
    }
    fs.writeFileSync(SHORTS_FILE, JSON.stringify([...postedVideos]), 'utf8');
    console.log("üóëÔ∏è Se han eliminado los Shorts antiguos.");
}

// üîç Funci√≥n para buscar nuevos Shorts
async function checkForNewShorts(client) {
    try {
        console.log("üîç Buscando nuevos Shorts de Doble 20...");

        const url = `https://www.googleapis.com/youtube/v3/search?key=${YOUTUBE_API_KEY}&channelId=${YOUTUBE_CHANNEL_ID}&part=snippet,id&order=date&maxResults=10`;
        const response = await axios.get(url);
        
        const videos = response.data.items;
        if (!videos || videos.length === 0) return;

        // üîç Filtrar solo Shorts (videos con "Short" en el t√≠tulo o duraci√≥n menor a 60s)
        const shorts = videos.filter(video => video.id.videoId && video.snippet.title.toLowerCase().includes("short"));

        if (shorts.length === 0) {
            console.log("‚è≥ No hay nuevos Shorts en las √∫ltimas 24 horas.");
            return;
        }

        const discordChannel = await client.channels.fetch(DISCORD_CHANNEL_ID);
        if (!discordChannel) {
            console.error("‚ö†Ô∏è No se pudo encontrar el canal de Discord.");
            return;
        }

        for (const short of shorts) {
            const videoId = short.id.videoId;
            if (postedVideos.has(videoId)) continue; // Si ya fue publicado, lo ignoramos

            const videoTitle = short.snippet.title;
            const videoUrl = `https://www.youtube.com/shorts/${videoId}`;

            // üìú Publicar en Discord
            await discordChannel.send(`üì∫ **¬°Nuevo Short de D&D en Doble 20!** üé≤‚ú®\nüìú **${videoTitle}**\nüîó ${videoUrl}`);

            // üìå Guardar la URL con la fecha actual
            postedVideos.set(videoId, Date.now());
        }

        // Guardar en el archivo temporal
        fs.writeFileSync(SHORTS_FILE, JSON.stringify([...postedVideos]), 'utf8');

        console.log(`‚úÖ Se han publicado ${shorts.length} Shorts en Discord.`);

    } catch (error) {
        console.error("‚ö†Ô∏è Error al verificar YouTube:", error);
    }
}

// ‚è≥ Revisar YouTube cada 24 horas y limpiar Shorts antiguos
setInterval(() => {
    checkForNewShorts(client);
    cleanOldShorts();
}, CHECK_INTERVAL);

client.once('ready', () => {
    console.log(`üì° Monitoreando YouTube cada 24 horas en ${client.user.tag}...`);
    checkForNewShorts(client);
    cleanOldShorts();
});

client.login(process.env.TOKEN);
